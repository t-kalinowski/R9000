---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# R9000

<!-- badges: start -->
<!-- badges: end -->

R9000 is a playground where I explored and sketched out some ideas for OOP in R.

## Installation

You can install the development version of R9000 like so:

``` r
remotes::install_github("t-kalinowski/R9000")
```

## Example

There is really only one interesting exported function: `%class%`. This is what it looks like:

```{r}
library(R9000)

Stopwatch %class% {
  ..init.. <- function(name = "", start = FALSE) {
    self$name <- name
    self$running <- FALSE
    self$start_time <- .POSIXct(NA_real_)
    self$stop_time <- .POSIXct(NA_real_)
    self$.total <- lap_time
    if (start)
      self()
  }
  ..call.. <- function() {
    # self() toggles start/stop
    if (self$running) {
      self$stop_time <- Sys.time()
      add(self$.total) <-  self$stop_time - self$start_time
    } else {
      self$start_time <- Sys.time()
    }

    self$running <- !self$running
  }

  lap_time %<-active% function(x) {
    if (!missing(x))
      stop("Protected property")
    if (self$running)
      Sys.time() - self$start_time
    else
      self$stop_time - self$start_time
  }

   total_time %<-active% function(x) {
    if (!missing(x))
      stop("Protected property")
    if (self$running)
      self$.total + lap_time()
    else
      self$.total
  }

  ..format.. <- function(x, ...) {
    sprintf(
      "Stopwatch: name = '%s', lap = %s, total = %s, %s",
      self$name,
      format(self$lap_time, digits = 3),
      format(self$total, digits = 3),
      if (self$running) "running" else "stopped")
  }

  reset <- ..init..
}
```

Calling `%class%` binds a class generator in the frame.
The class generator has an identical signature to `..init..()`, if it is defined.
Instantiate a class instance by calling the generator.

```{r}
str(formals(Stopwatch))
watch <- Stopwatch("Nap time")
```

The `print` method for class instances shows all
resolvable objects from `self$*`.

```{r}
watch
```


Invoke double dotted methods like `..format..()` via S3.
```{r}
cat(format(watch))

identical(format(watch), watch$..format..())
```


A call of `self()` invokes `self$..call..()`.
```{r}
watch()
cat(format(watch))
```


Active binding as properties.
```{r}
watch$lap_time
Sys.sleep(1)
watch$lap_time
try(watch$lap_time <- NA)
```



What works?

+ Single inheritance
+ Multiple inheritance / mixin subclasses  
  (object resolution order is flattened and fixed at instantiation time)
+ Instances are callable if a `..call..` method is defined.
+ Active bindings are supported.
+ Double-dotted ("dottr") methods are auto invoked via S3.
+ `self` and `super` are in scope of all methods. Both are callable and accessible with `$`.
+ `self` is available at initialization time.
+ `super` is available always, even at methods construction time.
+ `super("a_classname")` resolves a specific superclasses environment.
+ `self(...)` invokes `self$..call..(...)`.
+ The instance generator has the signature of `..init..()` if it is defined.
+ Instance generator has `$` method that lets you access methods directly,  
  bypassing instantiation.


Inheritance example:
```{r}
Class1 %class% {
  a_method <- function() {
    writeLines("Called Class1$a_method")
  }
}

Class2(Class1) %class% {
  a_method <- function() {
    writeLines("Entering Class2$a_method")
    super$a_method()
    writeLines("Exiting Class2$a_method")
  }
}

Class3(Class2) %class% {
  a_method <- function() {
    writeLines("Entering Class3$a_method")
    super$a_method()
    writeLines("Exiting Class3$a_method")
  }
}

x <- Class3()

class(x)

x$a_method()

x
```


Call `super()` to resolve a specific super class's environment.
```{r}
Skipper(Class3) %class% {
  a_method <- function(to_classname = NULL) {
    writeLines("Entering Skipper$a_method")
    super(to_classname)$a_method()
    writeLines("Exiting Skipper$a_method")
  }
}

x <- Skipper()
x$a_method()

x$a_method("Class3") # equivalent to default of NULL

x$a_method("Class2")

x$a_method("Class1")
```


Mixin example:
```{r}
Mixin %class% {
  mixin_method <- function(x, name) {
    cat("Called mixin_method\n")
  }
}

Class4(Class3, Mixin) %class% {
  a_method <- function() {
    writeLines("Entering Class4$a_method")
    self$mixin_method()
    writeLines("Exiting Class4$a_method")
  }
}

x <- Class4()

x

x$a_method()

x$mixin_method()

class(x)
```

Access class methods directly from the class generator, without instantiation.

```{r}
Class1$a_method()
```

Pass an instance of `self` as the first argument when accessing a method directly from the class generator and not from a class instance:
```{r}
Stopwatch$..format..(watch)
```
Active properties lose their "activeness" when invoked directly from the class generator, but also gain the ability to take an instance of `self` as the first argument.
```{r}
class(Stopwatch$lap_time)
Stopwatch$lap_time(self = watch)
```

